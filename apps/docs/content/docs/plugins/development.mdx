---
title: Plugin Development
description: How to create custom plugins.
---

# Plugin Development

The Mapwise Plugin System allows you to extend the core functionality in a modular, safe way.

## Anatomy of a Plugin

A plugin is an object implementing the `PluginDefinition` interface:

```typescript
interface PluginDefinition<TConfig = any> {
  id: string; // Unique identifier
  name?: string;
  version?: string;
  
  // Lifecycle Hooks
  onRegister?: (context: PluginContext) => void | Promise<void>;
  onUnregister?: (context: PluginContext) => void | Promise<void>;
  onMapReady?: (context: PluginContext) => void | Promise<void>;
  
  // Custom public API (exposed via controller.plugins.get('id'))
  api?: Record<string, any>;
}
```

## The Plugin Context

When registered, your plugin receives a `PluginContext` that gives access to the map system:

```typescript
interface PluginContext {
  // Accessors
  getMap: () => MapLibreMap | undefined;
  getMapId: () => string;
  
  // Managers
  layerRegistry: LayerRegistry;
  styleManager: StyleManager;
  eventBus: EventBus;
  
  // Interaction
  interactionMode: InteractionModeStore;
  cursorManager: CursorManager;
  keyboard: KeyboardManager;
  
  // State Storage (persisted with map)
  store: PluginStateStore;
}
```

## Example: A Simple Logging Plugin

```typescript
import { PluginDefinition } from '@mapwise/core';

export function createLoggerPlugin(): PluginDefinition {
  return {
    id: 'logger-plugin',
    name: 'Activity Logger',
    
    onRegister(ctx) {
      console.log('Plugin registered');
      
      // Listen to map events
      ctx.eventBus.on('layer:added', (event) => {
        console.log('New layer:', event.layerId);
      });
    },
    
    onMapReady(ctx) {
      console.log('Map is ready on canvas:', ctx.getMap()?.getCanvas());
    }
  };
}
```

## Best Practices

1.  **Use the Event Bus**: Don't monkey-patch the map instance. Use `ctx.eventBus` to communicate.
2.  **Clean Up**: Always remove event listeners in `onUnregister`.
3.  **Persist State**: Use `ctx.store` to save configuration. This ensures your plugin state is saved when `controller.serialize()` is called.
4.  **Respect Interaction Modes**: Check `ctx.interactionMode` before capturing pointer events to avoid conflict with other active tools.
